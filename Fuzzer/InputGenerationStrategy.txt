Jeremy Escobar
11/20/2023
CSE 543, Fall 2023

Input Generation Strategy:

My fuzzer, is implemented in Python, it initiates by reading a seed file and converting its contents into a byte array. This byte array serves as the foundation of my input for the fuzzing process. During each iteration, every byte in this buffer is evaluated for mutation. The mutation occurs with a probability of 13% (as defined by "MAX_PROBABILITY in my script), allowing for a substantial yet controlled degree of randomness in the input modification. 

When a byte is selected for mutation, it is replaced with a completely random byte within the full range (0 to 255). This comprehensive mutation range ensures that my fuzzer can explore a wide array of input scenarios, increasing the probability of triggering unexpected behaviors in the target programs (seg fault).

Furthermore, my fuzzer has been designed to automatically extend the input buffer after a certain number of iterations. Specifically, every 500 iterations (MAX_ITERATIONS), the fuzzer appends 10 new random bytes to the end of the buffer. This gradual expansion of the input size is a critical strategy for probing potential vulnerabilities related to buffer overflows or memory mismanagement.

The fuzzer has been updated through lengthy testing of Pseudo Random Number Generator (PRNG) seed and the number of iterations. I employed a bash script to test various PRNG seeds, leading to the identification of PRNG_seeds that consistently caused crashes in the target applications. Consequently, these PRNG_seeds have been integrated into the fuzzer_tester.sh script.

All essential files, including .crash, .txt, and seed, have been organized in specific folders within the provided zip archive for easy accessibility and management based on Sahil's post in Ed Discussion. 

In terms of broadening the fuzzer's application, a single seed file has been utilized to test programs (prog_3-9) located in the "all_programs" sub_folders. This seed file is generated by the "create_seed.py" script, also included in the src, ensuring a consistent starting point across different test programs. Then I also provided the original "test_programs" folder that contains prog_0,1,2. Each sub folder has a .crash, .txt and original seed and prog_0,1,2 binary. 

I also included a backup "fuzzer_backup" binary version of my python (fuzzer) using shebang #!/bin/bash/env python3 incase it does not work on test machine. The back up "fuzzer_backup" was created using pyinstaller making the python file an executable. 

Also important, My fuzzer will generate a file called "test.crash" which can be used to test the crash input created by the fuzzer to see if it crashes the prog_x binary. Since the fuzzer cannot append unique files like prog_x.crash it just creates a test.crash file in the working directory it is in. 

./fuzzer 123 500
./prog_x < test.crash